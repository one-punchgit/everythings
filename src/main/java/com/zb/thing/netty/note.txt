一. 网络通信和TCP/IP协议
OSI七层模型
TCP/IP模型
应用层 http telnet ftp tftp
端口号 tcp udp报文开头 会有16位二进制来表示  65536-1个
tcp三次握手
SYN=1 seq=x
SYN=1 ACK=1 ack=x+1 seq=y
ACK=1 ack=y+1
建立连接后进入established
三次使得双方都相互告知序列号起始值 并确认对方都收到

四次分手
FIN=1 seq=u
ACK=1 ack=u+1 seq=v
FIN=1 ACK=1 seq=w ack=u+1
ACK=1 seq=u+1 ack=w+1
time_wait状态 1.可靠的关闭连接 2.让迟来的报文有时间丢弃



键入网址到网页显示，期间发生了什么
1.http

2.真实地址查询-DNS
浏览器缓存 - 操作系统缓存 - 本地DNS服务器 - 根DNS服务器 - 顶级DNS服务器 - 权威DNS服务器

3.指南好帮手-协议栈
TCP UDP
IP:ICMP ARP
应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。
协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。
此外 IP 中还包括 ICMP 协议和 ARP 协议。
ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息。
ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。

4.可靠传输-TCP
生成TCP头部

5.远程定位-IP
生成IP头部

6.两点传输-MAC
IP头部前加上MAC头部 包含发送方和接收方MAC地址
查询ARP缓存 - 然后APR广播
ARP协议帮我们找到路由器的MAC地址(为什么是路由器的MAC地址???  如果目标设备不在同一个局域网内（即目标IP地址属于其他网络或子网），那么数据包首先会被发送到默认网关，而默认网关通常是接入互联网的路由器的局域网接口。此时，目标MAC地址就是那个路由器接口的MAC地址，而不是最终服务器的MAC地址)

7.出口-网卡
网卡驱动程序操作网卡进行发送数据

8.送别者-交换机
交换机的端口不具有MAC地址
交换机的MAC地址表主要包含: 设备的MAC地址 , 该设备连接在交换机哪个端口上
交换机就是根据这些信息判断,应该把包转发到哪里去
地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。
这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包

9.出境大门-路由器
网络包经过交换机后 到达路由器 并在此被转发到下一个路由器或目标设备
路由器基于IP 各个端口都具有MAC和IP地址
交换机基于以太网 不具有MAC地址
路由器接收到包时就检测MAC是否是自己的 否则就丢弃  MAC头部的作用就是将包送达到路由器 其中接收方MAC地址就是路由器端口的MAC地址
根据IP查询路由表
路由转发: 如果网关是一个ip地址 则还需要转发到改地址 还未到达目标机器 , 如果网关为空 则就找到了ip地址
知道对方的 IP 地址之后，接下来需要通过 ARP 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址







二. bio nio直接内存和零拷贝
socket 应用层和传输层抽象出来的一个接口
bio
每个请求都需要创建独立的线程，与对应的客户端进行数据处理。
当并发数大时，需要创建大量线程来处理连接，系统资源占用较大。
连接建立后，如果当前线程暂时没有数据可读，则当前线程会一直阻塞在 Read 操作上，造成线程资源浪费。

nio selector channel buffer

reactor模式
反应器模式 高效的异步io操作

零拷贝 减少不必要的文件复制传输 减少中间不必要的拷贝次数
传统数据传送
磁盘--------内核缓冲区--------用户程序缓冲区--------套接字发送缓冲区--------网络设备缓冲区
    DMA拷贝           CPU拷贝              CPU拷贝               DMA拷贝
  四次拷贝 四次上下文切换

mmap内存映射
磁盘--------用户程序缓冲区--------套接字缓冲区-------网络设备缓冲区
 DMA拷贝 内存映射

sendfile
Linux2.1支持
磁盘--------内核缓冲区--------套接字缓冲区--------网络设备
    DMA        cpu拷贝记录数据位置和大小描述符

splice
磁盘-------内核缓冲区--------套接字--------网络设备
               管道连接无需cpu拷贝


三. 深入理解Linux内核eqoll
同步异步 调用方是否主动获取结果
阻塞非阻塞 等待结果返回调用方的状态

select(int n ,fd_set readfds, fd_set writefds, fd_set excepfds, timeout) 有可读可写或者except 单个进程能监控最大文件数量1024
poll(pollfd fds, int nfds, timeout)

epoll
int epoll_create(int size)  创建一个eventpoll对象引用所有的socket
int epoll_ctl 添加删除socket  eventpoll 有一个等待列表引用线程  一个rdlist就绪列表引用有动作的socket
int epoll_wait

socket(发送缓冲区 接收缓冲区 等待队列-阻塞的线程)
cpu接收中断信号后 先将内核空间数据 写入接收缓冲区  并唤醒线程放入工作队列中

四. Netty使用和常用组件